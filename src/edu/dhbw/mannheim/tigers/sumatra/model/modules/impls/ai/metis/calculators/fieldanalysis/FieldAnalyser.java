/*
 * *********************************************************
 * Copyright (c) 2009 - 2011, DHBW Mannheim - Tigers Mannheim
 * Project: TIGERS - Sumatra
 * Date: 09.10.2011
 * Author(s): Paul
 * 
 * *********************************************************
 */
package edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.metis.calculators.fieldanalysis;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;

import org.apache.log4j.Logger;

import edu.dhbw.mannheim.tigers.sumatra.model.data.frames.AIInfoFrame;
import edu.dhbw.mannheim.tigers.sumatra.model.data.math.GeoMath;
import edu.dhbw.mannheim.tigers.sumatra.model.data.math.ParallelMath;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.fieldraster.EnhancedFieldAnalyser;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.fieldraster.FieldRasterGenerator;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.fieldraster.FieldRasterGenerator.EGeneratorTyp;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.rectangle.AIRectangle;
import edu.dhbw.mannheim.tigers.sumatra.model.data.modules.ai.rectangle.AIRectangleVector;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.TrackedBot;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.TrackedTigerBot;
import edu.dhbw.mannheim.tigers.sumatra.model.data.trackedobjects.ids.BotID;
import edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.config.AIConfig;
import edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.config.FieldRasterConfig;
import edu.dhbw.mannheim.tigers.sumatra.model.modules.impls.ai.metis.calculators.ACalculator;


/**
 * This {@link FieldAnalyser} uses the raster generated by the {@link FieldAnalyser} to create a scored field for
 * offensive and defensive robot positioning.
 * 
 * @author PaulB, OliverS
 * 
 */
public class FieldAnalyser extends ACalculator
{
	
	
	// --------------------------------------------------------------------------
	// --- variables and constants ----------------------------------------------
	// --------------------------------------------------------------------------
	private static final Logger		log	= Logger.getLogger(FieldAnalyser.class.getName());
	private FieldRasterConfig			fieldRasterConfig;
	
	private final AIRectangleVector	ratedRectangles;
	
	private ParallelMath					parallelMath;
	private FieldRasterGenerator		fieldRasterGenerator;
	private int								mode;
	private int								kind;
	
	
	// --------------------------------------------------------------------------
	// --- constructors ---------------------------------------------------------
	// --------------------------------------------------------------------------
	/**
	 * @param typ - decide with {@link EGeneratorTyp} if Main or Playfinder Field
	 */
	public FieldAnalyser(EGeneratorTyp typ)
	{
		fieldRasterConfig = AIConfig.getFieldRaster();
		fieldRasterGenerator = new FieldRasterGenerator(typ);
		ratedRectangles = new AIRectangleVector(fieldRasterGenerator);
		
		switch (typ)
		{
			case MAIN:
			{
				mode = fieldRasterConfig.getAnalysingMode();
				kind = fieldRasterConfig.getAnalysingKind();
				parallelMath = new ParallelMath(fieldRasterConfig.getAnalysingKind(), fieldRasterConfig.getAnalysingMode());
			}
				
				break;
			case PLAYFINDER:
			{
				mode = fieldRasterConfig.getPlayfnderAnalysingMode();
				kind = fieldRasterConfig.getPlayfinderAnalysingKind();
				parallelMath = new ParallelMath(fieldRasterConfig.getPlayfinderAnalysingKind(),
						fieldRasterConfig.getPlayfnderAnalysingMode());
			}
				break;
		}
		
		
	}
	
	
	// --------------------------------------------------------------------------
	// --- methods --------------------------------------------------------------
	// --------------------------------------------------------------------------
	@Override
	public void doCalc(AIInfoFrame curFrame, AIInfoFrame preFrame)
	{
		int countTigerBots = curFrame.worldFrame.tigerBotsVisible.size();
		int countFoeBots = curFrame.worldFrame.foeBots.size();
		int[] botPos = new int[countFoeBots + countTigerBots];
		float[] botSpeed = new float[(countFoeBots + countTigerBots) * 2];
		int botOurCount = 0;
		int i = 0;
		List<ArrayList<AIRectangle>> maxFoeTakenRectangles = new ArrayList<ArrayList<AIRectangle>>();
		List<ArrayList<AIRectangle>> maxTigersTakenRectangles = new ArrayList<ArrayList<AIRectangle>>();
		EnhancedFieldAnalyser enhancedFieldAnalyser = new EnhancedFieldAnalyser(ratedRectangles);
		
		// List for all Quadrants
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		maxFoeTakenRectangles.add(new ArrayList<AIRectangle>());
		// List for all Quadrants
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		maxTigersTakenRectangles.add(new ArrayList<AIRectangle>());
		
		// value of the quadrants
		float quadrantNr1 = 0;
		float quadrantNr2 = 0;
		float quadrantNr3 = 0;
		float quadrantNr4 = 0;
		
		for (Entry<BotID, TrackedTigerBot> bot : curFrame.worldFrame.tigerBotsVisible)
		{
			try
			{
				botPos[i] = fieldRasterGenerator.getAnalysingIDFromPosition(bot.getValue().getPos());
				botSpeed[2 * i] = bot.getValue().getVel().x();
				botSpeed[(2 * i) + 1] = bot.getValue().getVel().y();
				botOurCount++;
				i++;
			} catch (IllegalArgumentException ex)
			{
			}
		}
		for (Entry<BotID, TrackedBot> bot : curFrame.worldFrame.foeBots)
		{
			try
			{
				botSpeed[2 * i] = bot.getValue().getVel().x();
				botSpeed[(2 * i) + 1] = bot.getValue().getVel().y();
				botPos[i] = fieldRasterGenerator.getAnalysingIDFromPosition(bot.getValue().getPos());
				i++;
			} catch (IllegalArgumentException ex)
			{
			}
		}
		if (botPos.length > 0)
		{
			float[] rectangleValues = null;
			
			if ((mode == 1) && (kind == 1))
			{
				rectangleValues = parallelMath.calculateManalobisDistanceFieldRasterGPU(botPos, botSpeed, botOurCount,
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfRows(),
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfColumns());
			} else if ((mode == 2) && (kind == 1))
			{
				rectangleValues = parallelMath.calculateManalobisDistanceFieldRasterCPU(botPos, botSpeed, botOurCount,
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfRows(),
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfColumns());
			} else if ((mode == 1) && (kind == 2))
			{
				rectangleValues = parallelMath.calculateFieldRasterGPU(botPos, botOurCount,
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfRows(),
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfColumns());
			} else if ((mode == 2) && (kind == 2))
			{
				rectangleValues = parallelMath.calculateFieldRasterCPU(botPos, botOurCount,
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfRows(),
						fieldRasterGenerator.getAnalysingFactor() * fieldRasterGenerator.getNumberOfColumns());
			} else
			{
				log.warn("No fieldRaster while calculated, cause an error in the ai_config. (Mode or Kind ist wrong)");
			}
			
			if (rectangleValues != null)
			{
				for (int j = 0; j < rectangleValues.length; j++)
				{
					final AIRectangle actualRectangle = ratedRectangles.get(j);
					actualRectangle.setValue(rectangleValues[j]);
					
					int quadrant = GeoMath.checkQuadrant(actualRectangle.getMidPoint());
					switch (quadrant)
					{
						case 1:
							quadrantNr1 += actualRectangle.getValue();
							break;
						case 2:
							quadrantNr2 += actualRectangle.getValue();
							break;
						case 3:
							quadrantNr3 += actualRectangle.getValue();
							break;
						case 4:
							quadrantNr4 += actualRectangle.getValue();
							break;
					}
					
					
					// Set the highes or lows Value to max
					if (enhancedFieldAnalyser.getTotalMaximum() < Math.abs(actualRectangle.getValue()))
					{
						enhancedFieldAnalyser.setTotalMaximum(actualRectangle.getValue());
					}
					sortInMaximumsToQuadrants(actualRectangle, maxFoeTakenRectangles, maxTigersTakenRectangles);
				}
			}
		}
		
		
		enhancedFieldAnalyser.setMaxFoeTakenRectangleID(maxFoeTakenRectangles);
		enhancedFieldAnalyser.setMaxTigersTakenRectangleID(maxTigersTakenRectangles);
		enhancedFieldAnalyser.setScoringOfQuadrants(quadrantNr1, quadrantNr2, quadrantNr3, quadrantNr4);
		curFrame.tacticalInfo.setEnhancedFieldAnalyser(enhancedFieldAnalyser);
	}
	
	
	// --------------------------------------------------------------------------
	// --- getter/setter --------------------------------------------------------
	// --------------------------------------------------------------------------
	
	
	/**
	 * Goes trought the list, and set the maximum to the right quadrants
	 * 
	 * @param actualRectangle
	 * @param maxFoeTakenRectangles
	 * @param maxTigersTakenRectangles
	 */
	private void sortInMaximumsToQuadrants(AIRectangle actualRectangle,
			List<ArrayList<AIRectangle>> maxFoeTakenRectangles, List<ArrayList<AIRectangle>> maxTigersTakenRectangles)
	{
		switch (GeoMath.checkQuadrant(actualRectangle.getMidPoint()))
		{
			case 1:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(0);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(0);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
				
			}
				break;
			case 2:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(1);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(1);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			case 3:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(2);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(2);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			case 4:
			{
				ArrayList<AIRectangle> maxFoeList = maxFoeTakenRectangles.get(3);
				ArrayList<AIRectangle> maxTigersList = maxTigersTakenRectangles.get(3);
				
				isMaximum(actualRectangle, maxFoeList, maxTigersList);
			}
				break;
			default:
				break;
		}
	}
	
	
	/**
	 * Check if is a maximum, if yes, set the maximum if equal add to list.
	 * 
	 * @param maxTigersList
	 * @param maxFoeList
	 * @param actualRectangle
	 * 
	 */
	private void isMaximum(AIRectangle actualRectangle, ArrayList<AIRectangle> maxFoeList,
			ArrayList<AIRectangle> maxTigersList)
	{
		// TODO Epsilon bei gleicheit
		if ((maxFoeList.size() == 0) || (maxTigersList.size() == 0))
		{
			maxFoeList.add(actualRectangle);
			maxTigersList.add(actualRectangle);
			return;
		}
		
		if (ratedRectangles.get(maxFoeList.get(0).getRectangleID()).getValue() == actualRectangle.getValue())
		{
			maxFoeList.add(actualRectangle);
		} else if (ratedRectangles.get(maxFoeList.get(0).getRectangleID()).getValue() <= actualRectangle.getValue())
		{
			maxFoeList.clear();
			maxFoeList.add(actualRectangle);
		}
		
		if (ratedRectangles.get(maxTigersList.get(0).getRectangleID()).getValue() == actualRectangle.getValue())
		{
			maxTigersList.add(actualRectangle);
		} else if (ratedRectangles.get(maxTigersList.get(0).getRectangleID()).getValue() >= actualRectangle.getValue())
		{
			maxTigersList.clear();
			maxTigersList.add(actualRectangle);
		}
		
	}
	
	
	/**
	 * @return scored {@link AIRectangle}s within the {@link AIRectangleVector}.
	 */
	public AIRectangleVector getAnalysisRectangles()
	{
		return ratedRectangles;
	}
	
	
	@Override
	public void fallbackCalc(AIInfoFrame curFrame, AIInfoFrame preFrame)
	{
		curFrame.tacticalInfo.setEnhancedFieldAnalyser(new EnhancedFieldAnalyser(new AIRectangleVector(
				fieldRasterGenerator)));
	}
	
}
